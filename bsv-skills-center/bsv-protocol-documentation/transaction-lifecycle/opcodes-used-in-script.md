---
description: >-
  This is a list of all Script words, also known as opcodes, commands, or
  functions.
---

# Opcodes used in Script

OP\_NOP1-OP\_NOP10 were originally set aside to be used when HASH and other security functions become insecure due to improvements in computing.

False is zero or negative zero (using any number of bytes) or an empty array, and True is anything else.

Opcodes that will be activated in the [Chronicle Release](https://docs.bsvblockchain.org/network-topology/nodes/sv-node/chronicle-release#id-2.-opcodes) are indicated by an asterisk (e.g. OP\_VER\*).

#### Constants

When talking about scripts, these value-pushing words are usually omitted.

<table><thead><tr><th width="173">Word</th><th width="125">Opcode</th><th width="109">Input</th><th width="100">Output</th><th>Description</th></tr></thead><tbody><tr><td>OP_0, OP_FALSE</td><td>0<br>0x00</td><td>Nothing.</td><td>(empty value)</td><td>An empty array of bytes is pushed onto the stack. (This is not a no-op: an item is added to the stack.)</td></tr><tr><td>Pushdata Bytelength</td><td>1-75<br>0x01-0x4b</td><td>(special)</td><td>data</td><td>The next <em>opcode</em> bytes is data to be pushed onto the stack</td></tr><tr><td>OP_PUSHDATA1</td><td>76<br>0x4c</td><td>(special)</td><td>data</td><td>The next byte contains the number of bytes to be pushed onto the stack.</td></tr><tr><td>OP_PUSHDATA2</td><td>77<br>0x4d</td><td>(special)</td><td>data</td><td>The next two bytes contain the number of bytes to be pushed onto the stack in little endian order.</td></tr><tr><td>OP_PUSHDATA4</td><td>78<br>0x4e</td><td>(special)</td><td>data</td><td>The next four bytes contain the number of bytes to be pushed onto the stack in little endian order.</td></tr><tr><td>OP_1NEGATE</td><td>79<br>0x4f</td><td>Nothing.</td><td>-1</td><td>The number -1 is pushed onto the stack.</td></tr><tr><td>OP_1, OP_TRUE</td><td>81<br>0x51</td><td>Nothing.</td><td>1</td><td>The number 1 is pushed onto the stack.</td></tr><tr><td>OP_2-OP_16</td><td>82-96<br>0x52-0x60</td><td>Nothing.</td><td>2-16</td><td>The number in the word name (2-16) is pushed onto the stack.</td></tr></tbody></table>

#### Flow control

<table><thead><tr><th width="167">Word</th><th width="110">Opcode</th><th>Input</th><th width="131">Output</th><th>Description</th></tr></thead><tbody><tr><td>OP_NOP</td><td>97<br>0x61</td><td>Nothing</td><td>Nothing</td><td>Does nothing.</td></tr><tr><td>OP_VER*</td><td>98<br>0x62</td><td>Nothing</td><td>Transaction version</td><td>Puts the transaction version onto the stack.</td></tr><tr><td>OP_IF</td><td>99<br>0x63</td><td><p><code>[expression] IF</code></p><p> <code>[statement 1]</code></p><p><code>ENDIF</code><br>OR <code>[expression] IF</code></p><p> <code>[statement 1]</code></p><p><code>ELSE</code></p><p> <code>[statement 2]</code></p><p><code>ENDIF</code></p></td><td></td><td><p>If the top stack value is TRUE, statement 1 is executed.</p><p>If the top stack value is FALSE and ELSE is used, statement 2 is executed. If ELSE is NOT used, the script jumps to ENDIF. The top stack value is removed.</p></td></tr><tr><td>OP_NOTIF</td><td>100<br>0x64</td><td><p><code>[expression] NOTIF</code></p><p> <code>[statement 1]</code></p><p><code>ENDIF</code><br>OR <code>[expression] IF</code></p><p> <code>[statement 1]</code></p><p>ELSE</p><p> <code>[statement 2]</code></p><p><code>ENDIF</code></p></td><td></td><td><p>If the top stack value is FALSE, statement 1 is executed.</p><p>If the top stack value is TRUE and ELSE is used, statement 2 is executed. If ELSE is NOT used, the script jumps to ENDIF. The top stack value is removed.</p></td></tr><tr><td>OP_VERIF*</td><td>101<br>0x65</td><td>x1 = 4-byte array</td><td>Result of conditionally executed statement</td><td>Same semantics as: x1 transaction_version <code>OP_EQUAL OP_IF [statements] [OP_ELSE [statements]] OP_ENDIF OP_DROP</code>.</td></tr><tr><td>OP_VERNOTIF*</td><td>102<br>0x66</td><td>x1 = 4-byte array</td><td>Result of conditionally executed statement</td><td>Same semantics as: x1 transaction_version <code>OP_EQUAL OP_IFNOT [statements] [OP_ELSE [statements]] OP_ENDIF OP_DROP</code>.</td></tr><tr><td>OP_ELSE</td><td>103<br>0x67</td><td><p><code>[expression] IF</code></p><p> <code>[statement 1]</code></p><p>ELSE</p><p> <code>[statement 2]</code></p><p><code>ENDIF</code></p></td><td></td><td>If the preceding IF or NOTIF check was not valid then statement 2 is executed.</td></tr><tr><td>OP_ENDIF</td><td>104<br>0x68</td><td><p><code>[expression] IF</code><br><code>[statements]</code> <br><code>ELSE</code></p><p><code>[statements]</code> <br>ENDIF</p></td><td></td><td>Ends an if/else block. All blocks must end, or the transaction is invalid. An OP_ENDIF without a prior matching OP_IF or OP_NOTIF is also invalid.</td></tr><tr><td>OP_VERIFY</td><td>105<br>0x69</td><td>True / false</td><td>Nothing / <em>fail</em></td><td>Marks transaction as invalid if top stack value is not true. The top stack value is removed.</td></tr><tr><td>OP_RETURN</td><td>106<br>0x6a</td><td>Nothing</td><td><em>Ends script with top value on stack as final result</em></td><td>OP_RETURN can also be used to create "False Return" outputs with a scriptPubKey consisting of OP_FALSE OP_RETURN followed by data. Such outputs are provably unspendable and should be given a value of zero Satoshis. These outputs can be pruned from storage in the UTXO set, reducing its size. Currently the BitcoinSV network supports multiple FALSE RETURN outputs in a given transaction with each one capable of holding up to 100kB of data. After the Genesis upgrade in 2020 miners will be free to mine transactions containing FALSE RETURN outputs of any size.</td></tr></tbody></table>

#### Stack

| Word             | Opcode             | Input                | Output             | Description                                                                            |
| ---------------- | ------------------ | -------------------- | ------------------ | -------------------------------------------------------------------------------------- |
| OP\_TOALTSTACK   | <p>107<br>0x6b</p> | x1                   | (alt)x1            | Puts the input onto the top of the alt stack. Removes it from the main stack.          |
| OP\_FROMALTSTACK | <p>108<br>0x6c</p> | (alt)x1              | x1                 | Puts the input onto the top of the main stack. Removes it from the alt stack.          |
| OP\_2DROP        | <p>109<br>0x6d</p> | x1 x2                | Nothing            | Removes the top two stack items.                                                       |
| OP\_2DUP         | <p>110<br>0x6e</p> | x1 x2                | x1 x2 x1 x2        | Duplicates the top two stack items.                                                    |
| OP\_3DUP         | <p>111<br>0x6f</p> | x1 x2 x3             | x1 x2 x3 x1 x2 x3  | Duplicates the top three stack items.                                                  |
| OP\_2OVER        | <p>112<br>0x70</p> | x1 x2 x3 x4          | x1 x2 x3 x4 x1 x2  | Copies the pair of items two spaces back in the stack to the front.                    |
| OP\_2ROT         | <p>113<br>0x71</p> | x1 x2 x3 x4 x5 x6    | x3 x4 x5 x6 x1 x2  | The fifth and sixth items back are moved to the top of the stack.                      |
| OP\_2SWAP        | <p>114<br>0x72</p> | x1 x2 x3 x4          | x3 x4 x1 x2        | Swaps the top two pairs of items.                                                      |
| OP\_IFDUP        | <p>115<br>0x73</p> | x                    | x / x x            | If the top stack value is not 0, duplicate it.                                         |
| OP\_DEPTH        | <p>116<br>0x74</p> | Nothing              | \<Stack size>      | Counts the number of stack items onto the stack and places the value on the top        |
| OP\_DROP         | <p>117<br>0x75</p> | x                    | Nothing            | Removes the top stack item.                                                            |
| OP\_DUP          | <p>118<br>0x76</p> | x                    | x x                | Duplicates the top stack item.                                                         |
| OP\_NIP          | <p>119<br>0x77</p> | x1 x2                | x2                 | Removes the second-to-top stack item.                                                  |
| OP\_OVER         | <p>120<br>0x78</p> | x1 x2                | x1 x2 x1           | Copies the second-to-top stack item to the top.                                        |
| OP\_PICK         | <p>121<br>0x79</p> | xn ... x2 x1 x0 \<n> | xn ... x2 x1 x0 xn | The item _n_ back in the stack is copied to the top.                                   |
| OP\_ROLL         | <p>122<br>0x7a</p> | xn ... x2 x1 x0 \<n> | ... x2 x1 x0 xn    | The item _n_ back in the stack is moved to the top.                                    |
| OP\_ROT          | <p>123<br>0x7b</p> | x1 x2 x3             | x2 x3 x1           | The top three items on the stack are rotated to the left.                              |
| OP\_SWAP         | <p>124<br>0x7c</p> | x1 x2                | x2 x1              | The top two items on the stack are swapped.                                            |
| OP\_TUCK         | <p>125<br>0x7d</p> | x1 x2                | x2 x1 x2           | The item at the top of the stack is copied and inserted before the second-to-top item. |

#### Data Manipulation

| Word        | Opcode             | Input | Output  | Description                                                                    |
| ----------- | ------------------ | ----- | ------- | ------------------------------------------------------------------------------ |
| OP\_CAT     | <p>126<br>0x7e</p> | x1 x2 | out     | Concatenates two strings.                                                      |
| OP\_SPLIT   | <p>127<br>0x7f</p> | x n   | x1 x2   | Splits byte sequence x at position n.                                          |
| OP\_NUM2BIN | <p>128<br>0x80</p> | a b   | out     | Converts numeric value a into byte sequence of length b.                       |
| OP\_BIN2NUM | <p>129<br>0x81</p> | x     | out     | Converts byte sequence x into a numeric value.                                 |
| OP\_SIZE    | <p>130<br>0x82</p> | in    | in size | Pushes the string length of the top element of the stack (without popping it). |

#### Bitwise logic

| Word            | Opcode             | Input | Output           | Description                                             |
| --------------- | ------------------ | ----- | ---------------- | ------------------------------------------------------- |
| OP\_INVERT      | <p>131<br>0x83</p> | in    | out              | Flips all of the bits in the input.                     |
| OP\_AND         | <p>132<br>0x84</p> | x1 x2 | out              | Boolean _and_ between each bit in the inputs.           |
| OP\_OR          | <p>133<br>0x85</p> | x1 x2 | out              | Boolean _or_ between each bit in the inputs.            |
| OP\_XOR         | <p>134<br>0x86</p> | x1 x2 | out              | Boolean _exclusive or_ between each bit in the inputs.  |
| OP\_EQUAL       | <p>135<br>0x87</p> | x1 x2 | True / false     | Returns 1 if the inputs are exactly equal, 0 otherwise. |
| OP\_EQUALVERIFY | <p>136<br>0x88</p> | x1 x2 | Nothing / _fail_ | Same as OP\_EQUAL, but runs OP\_VERIFY afterward.       |

#### Arithmetic

BitcoinScript supports arithmetic on bignum values A bignum is a byte sequence that represents a numeric value. The length of the byte sequence must be less than or equal to 750,000 bytes. Byte sequences larger than 750,000 bytes are valid in Bitcoin however current rules dictate that they are not recognised as a valid numeric value.

Note that while some operations require parameters to be valid numeric values, they may produce byte sequences which are not valid numeric values (for example, OP\_MUL may produce a byte sequence which is too large to validly represent a numeric value).

<table><thead><tr><th width="245">Word</th><th width="96">Opcode</th><th width="94">Input</th><th width="85">Output</th><th>Description</th></tr></thead><tbody><tr><td>OP_1ADD</td><td>139<br>0x8b</td><td>in</td><td>out</td><td>1 is added to the input.</td></tr><tr><td>OP_1SUB</td><td>140<br>0x8c</td><td>in</td><td>out</td><td>1 is subtracted from the input.</td></tr><tr><td>OP_2MUL*</td><td>141<br>0x8d</td><td>in</td><td>out</td><td>The input is multiplied by 2.</td></tr><tr><td>OP_2DIV*</td><td>142<br>0x8e</td><td>in</td><td>out</td><td>The input is divided by 2.</td></tr><tr><td>OP_NEGATE</td><td>143<br>0x8f</td><td>in</td><td>out</td><td>The sign of the input is flipped.</td></tr><tr><td>OP_ABS</td><td>144<br>0x90</td><td>in</td><td>out</td><td>The input is made positive.</td></tr><tr><td>OP_NOT</td><td>145<br>0x91</td><td>in</td><td>out</td><td>If the input is 0 or 1, it is flipped. Otherwise the output will be 0.</td></tr><tr><td>OP_0NOTEQUAL</td><td>146<br>0x92</td><td>in</td><td>out</td><td>Returns 0 if the input is 0. 1 otherwise.</td></tr><tr><td>OP_ADD</td><td>147<br>0x93</td><td>a b</td><td>out</td><td>a is added to b.</td></tr><tr><td>OP_SUB</td><td>148<br>0x94</td><td>a b</td><td>out</td><td>b is subtracted from a.</td></tr><tr><td>OP_MUL</td><td>149<br>0x95</td><td>a b</td><td>out</td><td>a is multiplied by b.</td></tr><tr><td>OP_DIV</td><td>150<br>0x96</td><td>a b</td><td>out</td><td>a is divided by b.</td></tr><tr><td>OP_MOD</td><td>151<br>0x97</td><td>a b</td><td>out</td><td>Returns the remainder after dividing a by b.</td></tr><tr><td>OP_LSHIFT</td><td>152<br>0x98</td><td>a b</td><td>out</td><td>Logical left shift b bits. Sign data is discarded</td></tr><tr><td>OP_RSHIFT</td><td>153<br>0x99</td><td>a b</td><td>out</td><td>Logical right shift b bits. Sign data is discarded</td></tr><tr><td>OP_BOOLAND</td><td>154<br>0x9a</td><td>a b</td><td>out</td><td>If both a and b are not 0, the output is 1. Otherwise 0.</td></tr><tr><td>OP_BOOLOR</td><td>155<br>0x9b</td><td>a b</td><td>out</td><td>If a or b is not 0, the output is 1. Otherwise 0.</td></tr><tr><td>OP_NUMEQUAL</td><td>156<br>0x9c</td><td>a b</td><td>out</td><td>Returns 1 if the numbers are equal, 0 otherwise.</td></tr><tr><td>OP_NUMEQUALVERIFY</td><td>157<br>0x9d</td><td>a b</td><td>Nothing / <em>fail</em></td><td>Same as OP_NUMEQUAL, but runs OP_VERIFY afterward.</td></tr><tr><td>OP_NUMNOTEQUAL</td><td>158<br>0x9e</td><td>a b</td><td>out</td><td>Returns 1 if the numbers are not equal, 0 otherwise.</td></tr><tr><td>OP_LESSTHAN</td><td>159<br>0x9f</td><td>a b</td><td>out</td><td>Returns 1 if a is less than b, 0 otherwise.</td></tr><tr><td>OP_GREATERTHAN</td><td>160<br>0xa0</td><td>a b</td><td>out</td><td>Returns 1 if a is greater than b, 0 otherwise.</td></tr><tr><td>OP_LESSTHANOREQUAL</td><td>161<br>0xa1</td><td>a b</td><td>out</td><td>Returns 1 if a is less than or equal to b, 0 otherwise.</td></tr><tr><td>OP_GREATERTHANOREQUAL</td><td>162<br>0xa2</td><td>a b</td><td>out</td><td>Returns 1 if a is greater than or equal to b, 0 otherwise.</td></tr><tr><td>OP_MIN</td><td>163<br>0xa3</td><td>a b</td><td>out</td><td>Returns the smaller of a and b.</td></tr><tr><td>OP_MAX</td><td>164<br>0xa4</td><td>a b</td><td>out</td><td>Returns the larger of a and b.</td></tr><tr><td>OP_WITHIN</td><td>165<br>0xa5</td><td>x min max</td><td>out</td><td>Returns 1 if x is within the specified range (left-inclusive), 0 otherwise.</td></tr></tbody></table>

#### Cryptography

<table><thead><tr><th width="219">Word</th><th width="92">Opcode</th><th width="117">Input</th><th width="117">Output</th><th>Description</th></tr></thead><tbody><tr><td>OP_RIPEMD160</td><td>166<br>0xa6</td><td>in</td><td>hash</td><td>The input is hashed using RIPEMD-160.</td></tr><tr><td>OP_SHA1</td><td>167<br>0xa7</td><td>in</td><td>hash</td><td>The input is hashed using SHA-1.</td></tr><tr><td>OP_SHA256</td><td>168<br>0xa8</td><td>in</td><td>hash</td><td>The input is hashed using SHA-256.</td></tr><tr><td>OP_HASH160</td><td>169<br>0xa9</td><td>in</td><td>hash</td><td>The input is hashed twice: first with SHA-256 and then with RIPEMD-160.</td></tr><tr><td>OP_HASH256</td><td>170<br>0xaa</td><td>in</td><td>hash</td><td>The input is hashed two times with SHA-256.</td></tr><tr><td>OP_CODESEPARATOR</td><td>171<br>0xab</td><td>Nothing</td><td>Nothing</td><td>All of the signature checking words will only match signatures to the data after the most recently-executed OP_CODESEPARATOR.</td></tr><tr><td>OP_CHECKSIG</td><td>172<br>0xac</td><td>sig pubkey</td><td>True / false</td><td>The entire transaction's outputs, inputs, and script (from the most recently-executed OP_CODESEPARATOR to the end) are hashed. The signature used by OP_CHECKSIG must be a valid signature for this hash and public key. If it is, 1 is returned, 0 otherwise.</td></tr><tr><td>OP_CHECKSIGVERIFY</td><td>173<br>0xad</td><td>sig pubkey</td><td>Nothing / <em>fail</em></td><td>Same as OP_CHECKSIG, but OP_VERIFY is executed afterward.</td></tr><tr><td>OP_CHECKMULTISIG</td><td>174<br>0xae</td><td>x sig1 sig2 ... &#x3C;number of signatures> pub1 pub2 &#x3C;number of public keys></td><td>True / False</td><td>Compares the first signature against each public key until it finds an ECDSA match. Starting with the subsequent public key, it compares the second signature against each remaining public key until it finds an ECDSA match. The process is repeated until all signatures have been checked or not enough public keys remain to produce a successful result. All signatures need to match a public key. Because public keys are not checked again if they fail any signature comparison, signatures must be placed in the scriptSig using the same order as their corresponding public keys were placed in the scriptPubKey or redeemScript. If all signatures are valid, 1 is returned, 0 otherwise. Due to a bug, an extra unused value (x) is removed from the stack. Script spenders must account for this by adding a junk value (typically zero) to the stack.</td></tr><tr><td>OP_CHECKMULTISIGVERIFY</td><td>175<br>0xaf</td><td>x sig1 sig2 ... &#x3C;number of signatures> pub1 pub2 ... &#x3C;number of public keys></td><td>Nothing / <em>fail</em></td><td>Same as OP_CHECKMULTISIG, but OP_VERIFY is executed afterward.</td></tr></tbody></table>

#### Used NOP opcode identifiers

In Bitcoin's history, new opcodes were added that used reserved NO\_OP opcode identifiers. These opcodes have been reverted to the original OP\_NOP functionality.

| Word                                                     | Opcode             | Input                                | Output                                       | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| -------------------------------------------------------- | ------------------ | ------------------------------------ | -------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <p>OP_NOP2</p><p>(previously OP_CHECKLOCKTIMEVERIFY)</p> | <p>177<br>0xb1</p> | <p>Nothing</p><p>(Previously: x)</p> | <p>Nothing</p><p>(Previously: x or fail)</p> | <p>NO OPERATION</p><p><em>Evaluation process for UTXOs that pre-date genesis: Mark transaction as invalid if the top stack item is greater than the transaction's nLockTime field, otherwise script evaluation continues as though an OP_NOP was executed. Transaction is also invalid if 1. the stack is empty; or 2. the top stack item is negative; or 3. the top stack item is greater than or equal to 500000000 while the transaction's nLockTime field is less than 500000000, or vice versa; or 4. the input's nSequence field is equal to 0xffffffff. The precise semantics are described in</em> <a href="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki"><em>BIP 0065</em></a><em>.</em></p> |
| <p>OP_NOP3</p><p>(previously OP_CHECKSEQUENCEVERIFY)</p> | <p>178<br>0xb2</p> | <p>Nothing</p><p>(Previously: x)</p> | <p>Nothing</p><p>(Previously: x or fail)</p> | <p>NO OPERATION</p><p><em>Evaluation process for UTXOs that pre-date genesis: Mark transaction as invalid if the relative lock time of the input (enforced by</em> <a href="https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki"><em>BIP 0068</em></a> <em>with nSequence) is not equal to or longer than the value of the top stack item. The precise semantics are described in</em> <a href="https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki"><em>BIP 0112</em></a><em>.</em></p>                                                                                                                                                                                                          |

#### String operations



<table><thead><tr><th width="148">Word</th><th width="97">Opcode</th><th width="97">Input</th><th width="132">Output</th><th>Description</th></tr></thead><tbody><tr><td>OP_SUBSTR*</td><td>179<br>0xb3</td><td>x1 x2 x3</td><td>output string</td><td>The substring created from the string (x3) starting at the specified index (x2) and of the specified length (x1).</td></tr><tr><td>OP_LEFT*</td><td>180<br>0xb4</td><td>x1 x2</td><td>output string</td><td>The substring created from the string (x2) starting at the begining of the string and of the specified length (x1).</td></tr><tr><td>OP_RIGHT*</td><td>181<br>0xb5</td><td>x1 x2</td><td>output string</td><td>The substring created from the string (x2) using the specified number (x1) of rightmost characters.</td></tr></tbody></table>

#### Pseudo-words

These words are used internally for assisting with transaction matching. They are invalid if used in actual scripts.

<table><thead><tr><th width="226">Word</th><th width="129">Opcode</th><th>Description</th></tr></thead><tbody><tr><td>OP_PUBKEYHASH</td><td>253<br>0xfd</td><td>Represents a public key hashed with OP_HASH160.</td></tr><tr><td>OP_PUBKEY</td><td>254<br>0xfe</td><td>Represents a public key compatible with OP_CHECKSIG.</td></tr><tr><td>OP_INVALIDOPCODE</td><td>255<br>0xff</td><td>Matches any opcode that is not yet assigned.</td></tr></tbody></table>

#### Reserved words

Any opcode not assigned is also reserved. Using an unassigned opcode makes the transaction invalid.

<table><thead><tr><th width="221">Word</th><th width="166">Opcode</th><th>When used...</th></tr></thead><tbody><tr><td>OP_RESERVED</td><td>80<br>0x50</td><td>Transaction is invalid unless occuring in an unexecuted OP_IF branch</td></tr><tr><td>OP_RESERVED1</td><td>137<br>0x89</td><td>Transaction is invalid unless occuring in an unexecuted OP_IF branch</td></tr><tr><td>OP_RESERVED2</td><td>138<br>0x8a</td><td>Transaction is invalid unless occuring in an unexecuted OP_IF branch</td></tr><tr><td>OP_NOP1, OP_NOP4-OP_NOP10</td><td>176, 179-185<br>0xb0, 0xb3-0xb9</td><td>The word is ignored. Does not mark transaction as invalid.</td></tr></tbody></table>

### Examples

For examples of common Bitcoin transaction scripts please see Bitcoin Transactions

### Attribution

This content is based on content sourced from [https://en.bitcoin.it/wiki/Script](https://en.bitcoin.it/wiki/Script) under [Creative Commons Attribution 3.0](https://creativecommons.org/licenses/by/3.0/). Although it may have been extensively revised and updated we acknowledge the original authors.
